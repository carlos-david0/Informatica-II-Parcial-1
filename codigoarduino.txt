//defino pines para el 74hc595 de las filas(1)
int relojF = 7;
int latchF = 5;
int dataF = 6;
//defino pines para el 74hc595 de las columnas(0)
int relojC = 3;
int latchC = 4;
int dataC = 2;

void verificacion(unsigned short int tiempo, unsigned short int iteraciones) {
  for (unsigned short int i = 0; i < iteraciones; i++){
	digitalWrite(latchC, LOW);
    shiftOut(dataC, relojC, LSBFIRST, 0); 
    digitalWrite(latchC, HIGH);
    digitalWrite(latchF, LOW);
    shiftOut(dataF, relojF, LSBFIRST, 255);
    digitalWrite(latchF, HIGH);
    delay(tiempo*1000);
    digitalWrite(latchF, LOW);
    shiftOut(dataF, relojF, LSBFIRST, 0);
    digitalWrite(latchF, HIGH);
    delay(tiempo*1000);
  }
}

//Funciones que generan las matrices de los patrones,retornan la dirección de memoria

#include <stdlib.h>

bool** crear_matriz(short filas, short columnas);
void liberar_memoria(bool** apuntador_matriz,short filas,short columnas);
bool** patron_1(short filas, short columnas);
bool** patron_2(short filas, short columnas);
bool** patron_3(short filas, short columnas);
bool** patron_4(short filas, short columnas);


bool** crear_matriz(short filas, short columnas)
{
    bool** matriz= new bool*[filas/2];
    for(short i=0;i<filas;i++){
        matriz[i]= new bool[columnas];
    }
    return matriz;
}

void liberar_memoria(bool** apuntador_matriz,short filas,short columnas){
    for(short i=0;i<filas;i++){
        delete[] apuntador_matriz[i];
    }
    delete[] apuntador_matriz;
}

//PATRON 1
bool** patron_1(short filas, short columnas)
{
    bool** patron_1=crear_matriz(filas/2,columnas);
    //creo patron sobre la matriz
    short lim_superior=columnas/2, lim_inferior=lim_superior-1; //matriz 8*8 serian 4 y 3
    while(lim_superior<columnas){
        for (short i=0;i<filas/2;i++){
            for(short j=0;j<columnas;j++){
                if(j<=lim_superior && j>=lim_inferior){
                    *(*(patron_1+i)+j)=1;
                }
                else{
                    *(*(patron_1+i)+j)=0;
                }
            }
            lim_inferior--;
            lim_superior++;
        }
    }
    return patron_1;
}

//PATRON 2
bool** patron_2(short filas, short columnas)
{
    bool** patron_2=crear_matriz(filas/2,columnas);
    //creo patron sobre la matriz
    for(short i=0;i<filas/2;i++){
        for(short j=columnas-1;j>=columnas/2;j--){ //columnas-1 representa el valor máximo que se puede recorrer en las columnas
            *(*(patron_2+i)+i)=1;
            if(j+i==columnas-1)
                *(*(patron_2+i)+j)=1;
        }
    }
    return patron_2;
}


//PATRON 3
bool** patron_3(short filas, short columnas)
{
    bool** patron_3=crear_matriz((filas/2)-1, columnas);
    //creo patron sobre la matriz
    for(short i=0;i<(filas/2)-1;i++){
        for(short j=i/2;j<columnas;j+=3){
            *(*(patron_3+i)+j)=1;
            if(j!=7){
                *(*(patron_3+i)+(j+1))=1;
            }
        }
    }
    return patron_3;
}


//PATRON 4
bool** patron_4(short filas, short columnas)
{
    bool** patron_4=crear_matriz(filas/2,columnas);
    //creo patron sobre la matriz
    for(short i=0;i<filas/2;i++){
        for(short j=i;j<i+(columnas/2);j++){
            *(*(patron_4+i)+j)=1;
        }
    }
    return patron_4;
}

void setup() {
  Serial.begin(9600);
  pinMode(latchC, OUTPUT);
  pinMode(relojC, OUTPUT);
  pinMode(dataC, OUTPUT);
  pinMode(latchF, OUTPUT);
  pinMode(relojF, OUTPUT);
  pinMode(dataF, OUTPUT);
}

void loop() {

}
